package petStore.testsBase;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.tools.ant.util.FileUtils;
import org.testng.annotations.Test;
import org.testng.asserts.SoftAssert;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class JSONComparatorTest {

    SoftAssert softAssert = new SoftAssert();

    @Test
    public void testJsonEquality() throws IOException {
        // Create the first JSON object
        String json1 = new String(Files.readAllBytes(Paths.get("src/test/java/petStore/testsBase/json1.json")));
        String json2 = new String(Files.readAllBytes(Paths.get("src/test/java/petStore/testsBase/json2.json")));
        // Create the second JSON object

        // Assert the equality of the two JSON objects and print the differences
        assertJsonEquality(json1, json2);
        softAssert.assertAll();
    }

    private void assertJsonEquality(String json1, String json2) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        JsonNode node1 = mapper.readTree(json1);
        JsonNode node2 = mapper.readTree(json2);

        compareJsonNodes(node1, node2, "");
    }

    private void compareJsonNodes(JsonNode node1, JsonNode node2, String currentPath) {
        if (node1.equals(node2)) {
            return; // JSON nodes are equal
        }

        if (node1.isObject() && node2.isObject()) {
            ObjectNode objectNode1 = (ObjectNode) node1;
            ObjectNode objectNode2 = (ObjectNode) node2;

            Set<String> fieldNames1 = new HashSet<>();
            Set<String> originalFieldNames1 = new HashSet<>();
            objectNode1.fieldNames().forEachRemaining(fieldNames1::add);
            objectNode1.fieldNames().forEachRemaining(originalFieldNames1::add);// Store a copy of the field name


            Set<String> fieldNames2 = new HashSet<>();
            objectNode2.fieldNames().forEachRemaining(fieldNames2::add);

            fieldNames1.removeAll(fieldNames2);

            if (!fieldNames1.isEmpty()) {
                System.out.println("Fields present in first JSON but not in second JSON at path " + currentPath + ": " + fieldNames1);
            }
            fieldNames1.clear();
            fieldNames1.addAll(originalFieldNames1);

            fieldNames2.removeAll(fieldNames1);
            if (!fieldNames2.isEmpty()) {
                System.out.println("Fields present in second JSON but not in first JSON at path " + currentPath + ": " + fieldNames2);
            }

            objectNode1.fieldNames().forEachRemaining(fieldName -> {
                JsonNode fieldNode1 = objectNode1.get(fieldName);
                JsonNode fieldNode2 = objectNode2.get(fieldName);

                String fieldPath = currentPath + "/" + fieldName;
                compareJsonNodes(fieldNode1, fieldNode2, fieldPath);
            });
        } else if (node1.isArray() && node2.isArray()) {
            ArrayNode arrayNode1 = (ArrayNode) node1;
            ArrayNode arrayNode2 = (ArrayNode) node2;

            if (arrayNode1.size() != arrayNode2.size()) {
                System.out.println("Difference: Array size mismatch at path " + currentPath);
                return;
            }

            for (int i = 0; i < arrayNode1.size(); i++) {
                compareJsonNodes(arrayNode1.get(i), arrayNode2.get(i), currentPath + "[" + i + "]");
            }
        } else {
            softAssert.fail(currentPath + ": expected " + node1 + " but get " + node2);
        }
    }

}

